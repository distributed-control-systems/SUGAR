function varargout= subsref(objs,subs)


% SUBSREF Custom implementation of the subsref function for multivectors.
%
% SYNTAX:
%   value = objs(indices)      % Access coefficients or matrix elements
%   mv = objs{indices}         % Access components as multivectors
%
% DESCRIPTION:
%   This function overloads the built-in `subsref` function to allow
%   flexible indexing for objects of the multivector (MV) class. It
%   supports accessing:
%     - Coefficients or elements via `()`
%     - Multivectors via `{}`
%
%   The function distinguishes between numeric and symbolic coefficients
%   and handles indexing accordingly. Note that this implementation
%   requires further reformatting and improvement for clarity and coverage.
%
% INPUT:
%   objs : Multivector (MV) or array of multivectors to be indexed.
%   subs : Subscripted indexing structure generated by MATLAB during
%          indexed operations.
%
% OUTPUT:
%   varargout : The value(s) corresponding to the indexed elements or
%               multivectors, returned as numeric, symbolic, or MV objects.
%
% NOTES:
%   - Indexing with symbolic coefficients is partially supported.
%   - This implementation needs further work for robustness and clarity.
%
% EXAMPLES:
%   % Access the first coefficient of a multivector
%   value = mv(1);
%
%   % Access the first basis component as a multivector
%   component = mv{1};
%
%   % Access elements in a multivector array
%   element = mvArray(1, 2);
%
% REFERENCES:
%   - MATLAB documentation for subsref
%
% TODO:
%   - Refactor the function for clarity and maintainability.
%   - Expand support for symbolic indexing cases.
%   - Improve error handling for unknown indexing types.


% Access vector elements as it where a simple vector.
% ()->array value, of the coefficients or the elements of the matrix
% {}-> MV returns a multivector

% THIS FILE MUST BE REFORMATED!!!!
if size(subs,2)>1
  switch subs(1).type  
    case '()' | '{}'
            [varargout{1:nargout}]=builtin('subsref',objs,subs(1));
            varargout{1:nargout}=builtin('subsref',varargout{end},subs(2:end));
      otherwise
          try
        [varargout{1:nargout}]=builtin('subsref',objs,subs);  
          catch
              builtin('subsref',objs,subs)
          end
  end
    
%             o=varargout{end};
%             varargout={o.subsref(subs(2:end))};
else
switch subs(1).type
    case '()'
        [m,n]=size(objs);
        if m*n==1
            % care, numeric or basis-based
            elements=subs(1).subs{1};
            c=class(elements);
            if c=="double"
                varargout={builtin('subsref',objs.vector,subs(1))};
            elseif c=="MV"
                if class(elements.vector)=="double"
                    M=abs(elements.vector)>1e-6;
                    I=find(M);
                    s.type='()';
                    s.subs={I};
                    varargout={builtin('subsref',objs.vector,s)};
                else
                    error("Unable to perform indexing with symbolic coeficients")
                end


            else
                error("Not known indexing")
            end
        else
            [varargout{1:nargout}]=builtin('subsref',objs,subs);
        end
%         if size(subs,2)>1
%             %[varargout{1:nargout}]=builtin('subsref',varargout{end},subs(2:end));
%             o=varargout{end};
%             varargout={o.subsref(subs(2:end))};

%         end
    case '{}'
        [m,n]=size(objs);
        if m*n==1
            elements=subs(1).subs{1};

            c=class(elements);
            if c=="double"
                M=zeros(1,2^sum(objs.Lsignature));
                M(elements)=1;
                subs(1).subs={1};
                varargout={MV(objs.vector.*M,objs.Lsignature,objs.REPR)};
            elseif c=="MV"
                if class(elements.vector)=="double"
                    M=abs(elements.vector)>1e-6;
                    varargout={MV(objs.vector.*M,objs.Lsignature,objs.REPR)};
                else
                    error("Unable to perform indexing with symbolic coeficients")
                end


            else
                error("Not known indexing")
            end

        else
            % So, we want some components of the MV that
            % conform the matrix
            %lets retrive the MV components for each element of
            %the matrix
            s.type='()';
            M=sym(zeros(m,n));
            for i=1:m
                for j=1:n

                    s.subs={[i] [j]};
                    e=builtin('subsref',objs,s);%objs(i,j);

                    s.subs={[subs(1).subs{1}]};
                    % care, numeric or basis-based
                    elements=subs(1).subs{1};
            c=class(elements);
            if c=="double"
                M(i,j)=builtin('subsref',e.vector,subs(1));
            elseif c=="MV"
                if class(elements.vector)=="double"
                    MM=abs(elements.vector)>1e-6;
                    I=find(MM);
                    s.type='()';
                    s.subs={I};
                    M(i,j)=builtin('subsref',e.vector,s);
                else
                    error("Unable to perform indexing with symbolic coeficients")
                end


            else
                error("Not known indexing")
            end


     %%%               M(i,j)=builtin('subsref',e.vector,s);

                end
            end
            [varargout{1:nargout}]=M;

        end
        if size(subs,2)>1
            %[varargout{1:nargout}]=builtin('subsref',varargout{end},subs(2:end));
            o=varargout{end};
            varargout={o.subsref(subs(2:end))};

        end
    otherwise
        try
        [varargout{1:nargout}]=builtin('subsref',objs,subs);
        catch
            builtin('subsref',objs,subs);
            varargout{1:nargout}="";
        end
end
end
end



